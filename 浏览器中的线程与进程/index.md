
 > ## 此篇文章描述 线程 与 进程 的关系
 >     从网上文章提取的一些总结，咱们也不是搞系统的，了解好概念）
 >     然后从浏览器和计算机的角度来进行理解
 

 * 概念：
 >   进程是系统分配和管理资源的基本单位
 >   线程是CPU调度和分派的基本单位

 * 关系：
  >   每个应用必须要有一个进程，一个进程必须要有一个线程
      进程拥有独立的内存空间，每启动一个进程，系统都会分配地址空间，建立数据表来维护代码段，建立堆栈段和数据段
      且进程之间的通信必须遵从进程通信机制，有几种方式，大家感兴趣可以去看看
      
      同一进程下的所有线程共享分配的内存和数据，所以通信非常容易
      
      因为进程有自己的内存空间，举个例子，比如浏览器中的一个tab页挂了，其他的tab是不会收到影响的(保护模式下)
      而线程没有自己的内存空间，所以一个线程出问题，会导致这个进程出现问题
      
      线程适用于需要共享变量情况比较频繁的情况
      
      
      然后说下cpu和内存
      首先是计算机的cpu，中心处理器，是计算机的核心，负责对数据进行处理，运算
      还有就是计算机的内存，cpu接收数据必须从内存来。
      所以程序都是运行在内存上的，现在有多cpu，但是它们的一端肯定是内存
      且只有cpu空闲时数据才可以通过内存传输
      
      还有些额外的知识点，当内存不够时，系统会自动从硬盘中拿出一部分作为虚拟内存，但是和物理内存的速度时无法比较的
      内存泄漏，泄漏这一词用的很不恰当，字面意思像是从内存中漏了，没了，但其实指的是系统无法被释放的内存，只能手动释放
      js 的 闭包就属于内存泄漏，因为js是在执行栈上执行的
      也就是在内存中，一个函数执行完了，得到了释放。
      但如果是闭包的话，函数的作用域链会保留上层的活动对象，就会一直保存在内存中
      
      再回到正题
      浏览器本身也是一个进程，windows上打开chrome,在任务管理器里面可以看到进程
      且当前tab页打开f12开发工具，它也是一个独立的线程，所以虽然它们之间有很多的联系，但又是互不影响运行的(感觉这样说也不太对)
      且浏览器本身是个多线程的应用，每打开一个tab页都是新加了一条进程。
     
  * ! 浏览器只有一个主进程和其他的进程 

  * 主进程的作用是：
  >   1.负责浏览器的显示，用户的交互（一些设置），前进，后退
      2.赋值管理其他进程
      3.管理网络资源
      4.最重要的 将Renderer进程获取到的bitMap 绘制到用户界面
   
  * 其他的进程：
  >   1.第三方插件进程：每个插件对应一个进程
      2.GPU进程： 用于3d绘制，最多一个
      3.Renderer进程： 内部是多线程的 主要控制页面渲染，脚本执行，事件处理等
  
  * Renderer进程本身包括很多和前端息息相关的线程
  *   1.GUI渲染线程：
  >       负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等
          在页面需要重绘或者回流时，GUI线程启动。
          GUI线程与js引擎线程互斥，在js引擎运行时，GUI会被挂起。
          在js引擎执行完一个宏任务后，这个时候执行栈处于为空的情况，GUI运行，然后运行结束，开始下一个宏任务。
  *   2.js引擎线程：
  >       负责运行和解析js代码
          js引擎时单线程的
        
          这里说一下Worker,由于js是单线程的，所以不适合做大量的计算，这样会阻塞渲染线程
          Worker是Renderer进程的一个子线程，与js线程通信使用postMessage API(后面会专门做一次worker的文章)
          Worker不能访问dom
          Worker适用于复杂的运算，但不要滥用。
    
          webWorker（worker） 和 sharedWork从字面意思就可以看出区别
          一个是属于某个renderer的 ， 一个是属于所有的renderer的
          sharedWork是一个进程
  
  *   3.事件触发线程：
  >       用来控制事件循环
          当js解析到WebAPIs（宏任务）时，就会在任务注册表注册函数
          当对应的事件符合触发条件被触发时，就把该函数推入任务队列，队列的规则是先入先出，所以后来的事件会被推入队尾
     
          WebAPIs包括定时器，用户事件，异步请求，可以详见js执行机制
          每一类都会由对应的线程维护，因为线程增加比较容易，维护起来页更容易。
          像定时器，虽然可以设置为0，但最小时间规定为4ms
   
  * 上面提到进程和进程之间的通信需要遵循通信机制 
  >   主进程和Renderer进程不清楚用的是那种机制，可能是管道吧（只是猜测）反正肯定是双向的
    过程如下
    
  >  Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程
    Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染
    渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染
    当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）
    最后Render进程将结果传递给Browser进程
    Browser进程接收到结果并将结果绘制出来
    

{
  /**
   * js的执行机制（只讨论在浏览器上运行的情况，不讨论node）
   * 
   * 在分析之前，有以下几个概念：
   *  1.调用堆栈
   *    栈： js的执行环境（和js执行期密切相关，所以知识都是串联的，学习一个知识点会暴露出更多的与之相关的知识点，这些知识点会更加方便你理解，好奇心很重要）
   *    堆： 为变量，函数分配内存的地方
   *    栈采用后进先出的概念（LIFO）,当前一个任务执行后，弹出，执行下一个，如果没有，就会去读取浏览器的回调队列
   *    调用堆栈是js引擎分配的，可以进入任务队列（宏微任务队列）的是（WebAPIs和异步请求，点击事件等）和 微任务（是js自身的）
   *    所以js可以不用去关心宏任务，这是由浏览器自身去实现的，关心的是自身的微任务
   *  
   *  2.任务队列 
   *    任务队列分为宏任务和微任务，共同性是都是异步
   *    异步任务会被送进任务注册表（event table）进行函数注册，注册好了 送进任务队列
   *    宏任务包括（script，setTimeOut,setInterval,requestAnimationFrame(做动画的),I/O,UI交互，postMessage，MessageChannel（在worker中使用的））
   *    微任务包括（Promise.then catch finally，MutationObserve(观察dom的)）Object.observe已被废弃，由proxy代替
   *    宏任务就是浏览器实现的，由浏览器单开线程维护
   *    微任务储存在微任务队列中由js引擎维护
   * 
   *    任务队列会根据宏微进行划分在不同的任务队列运行
   * 
   *  3.回调队列
   *     任务队列执行后得到的可执行函数会被推入回调队列等待执行
   *     比如setTimeOut(fn,3) 代码会在任务队列中执行3秒，得到的可执行函数fn会被推入回调队列。
   *     fn的具体执行情况要由执行环境绝定
   * 
   *  4.事件循环（经常被问的event loop本loop）
   *    概念：每一个js线程都由一个独立的event loop
   *         每一个WebWorker都有一个独立的event loop
   * 
   *    每进行一次循环称为tick
   *    步骤如下：
   *      执行一个宏任务（结合上述，在一个页面被加载到浏览器后，第一个宏任务为第一个script）
   *      如果执行过程中遇到微任务，推入当前宏任务的微任务队列中
   *      当前宏任务执行完成后，执行微任务队列中的所有微任务（依次执行）
   *      宏任务执行完后，会触发一次重绘，由GUI线程接管，注意的的GUI与js进程是互斥的，俩者同时只存在一个，另一个会被挂起
   *      渲染完毕，GUI被挂起，js引擎继续执行，开始下一个宏任务
   *    
   * 
   * 浏览器本身是支持多线程的（这是必然的）
   * 在一个标签页中至少有三个线程是必须实现的
   * 1.js引擎线程（无论什么情况都只有一个js线程在运行
   *   js引擎中有一个monitoring process线程会监听js 主线程（执行环境），一旦为空，就会去读取回调队列的任务）
   * 2.GUI渲染线程，当页面需要重绘或者回流时触发，平时大多数时间被挂起，需要的时候再被放下来，
   *   如果GUI有更新，会被保存在一个队列中，当执行栈为空时执行（其实就是咱们说的一个宏任务执行完，下一个宏任务执行前）
   * 3.事件触发线程，包括WebAPIs啊，点击事件啊，xmlHttpRequest啊，fetch啊什么的都由此线程调度
   * 
   * 
   * node与浏览器主要的差异在于将微任务清空的时间点，如果有疑问的话，可以自己去查找这方面的资料
   * 
   * 还有async 和 await 
   * async 可以等同理解为promise ， 属于微任务 但是如果async 里面有 await  且 await  后面的函数返回的是个promise 那么 await 会阻塞代码执行
   * 所以如果没有await  或者 await等的不是一个promise  那么 就可以等同于一个同步代码
   */
  //附上一道小习题，如果理解了 使非常简单的  
  let a = 3

  setTimeout(() => {
    console.log(a)
    Promise.resolve().then(() => {
      console.log('p2')
    })
    console.log('p2start?')
  }, 100);


  Promise.resolve().then(() => {
    console.log('p1')
  })

  console.log(a)
}